// ZoneNode.js - Orbital zone node class

class ZoneNode extends NodeBase {
    constructor(id = null) {
        super(NodeTypes.Zone, id);
        this.nodeName = 'Zone';
        this.fontStyle = 'italic';
        
        // Zone properties
        this.zone = 'PrimaryBiosphere'; // InnerCauldron, PrimaryBiosphere, OuterReaches
        this.zoneSize = 'Normal'; // Weak, Normal, Dominant
    }

    generate() {
        super.generate();
        // Zones are typically generated by their parent system
        this.updateDescription();
    }

    generateZoneContent() {
        // Clear existing children
        this.children = [];
        
        // Determine number of elements based on zone size and type
        const numElements = this.determineZoneElements();
        
        for (let i = 0; i < numElements; i++) {
            const element = this.generateZoneElement();
            if (element) {
                this.addChild(element);
            }
        }
        
        this.updateDescription();
    }

    determineZoneElements() {
        let baseChance = 70; // Base chance for element generation
        
        // Modify based on zone size
        switch (this.zoneSize) {
            case 'Weak':
                baseChance = 40;
                break;
            case 'Normal':
                baseChance = 70;
                break;
            case 'Dominant':
                baseChance = 90;
                break;
        }
        
        // Determine number of elements
        let numElements = 0;
        
        // Primary element
        if (RollD100() <= baseChance) {
            numElements = 1;
            
            // Chance for additional elements in dominant zones
            if (this.zoneSize === 'Dominant' && RollD100() <= 50) {
                numElements = 2;
            }
            
            // Very rare chance for three elements
            if (this.zoneSize === 'Dominant' && RollD100() <= 15) {
                numElements = 3;
            }
        }
        
        return numElements;
    }

    generateZoneElement() {
        const roll = RollD100();
        let element = null;
        
        // Element type depends on the zone
        switch (this.zone) {
            case 'InnerCauldron':
                element = this.generateInnerCauldronElement(roll);
                break;
            case 'PrimaryBiosphere':
                element = this.generatePrimaryBiosphereElement(roll);
                break;
            case 'OuterReaches':
                element = this.generateOuterReachesElement(roll);
                break;
        }
        
        if (element) {
            element.zone = this.zone;
            element.generate();
        }
        
        return element;
    }

    generateInnerCauldronElement(roll) {
        if (roll <= 30) {
            const planet = createNode(NodeTypes.Planet);
            planet.nodeName = this.generatePlanetName();
            return planet;
        } else if (roll <= 50) {
            const asteroids = createNode(NodeTypes.AsteroidBelt);
            asteroids.nodeName = 'Asteroid Belt';
            return asteroids;
        } else if (roll <= 65) {
            const cluster = createNode(NodeTypes.AsteroidCluster);
            cluster.nodeName = 'Asteroid Cluster';
            return cluster;
        } else if (roll <= 75) {
            const derelict = createNode(NodeTypes.DerelictStation);
            derelict.nodeName = 'Derelict Station';
            return derelict;
        } else if (roll <= 85) {
            const cloud = createNode(NodeTypes.DustCloud);
            cloud.nodeName = 'Dust Cloud';
            return cloud;
        } else if (roll <= 95) {
            const flares = createNode(NodeTypes.SolarFlares);
            flares.nodeName = 'Solar Flares';
            return flares;
        } else {
            const radiation = createNode(NodeTypes.RadiationBursts);
            radiation.nodeName = 'Radiation Bursts';
            return radiation;
        }
    }

    generatePrimaryBiosphereElement(roll) {
        if (roll <= 40) {
            const planet = createNode(NodeTypes.Planet);
            planet.nodeName = this.generatePlanetName();
            return planet;
        } else if (roll <= 60) {
            const gasGiant = createNode(NodeTypes.GasGiant);
            gasGiant.nodeName = this.generateGasGiantName();
            return gasGiant;
        } else if (roll <= 75) {
            const asteroids = createNode(NodeTypes.AsteroidBelt);
            asteroids.nodeName = 'Asteroid Belt';
            return asteroids;
        } else if (roll <= 85) {
            const cluster = createNode(NodeTypes.AsteroidCluster);
            cluster.nodeName = 'Asteroid Cluster';
            return cluster;
        } else if (roll <= 95) {
            const derelict = createNode(NodeTypes.DerelictStation);
            derelict.nodeName = 'Derelict Station';
            return derelict;
        } else {
            const graveyard = createNode(NodeTypes.StarshipGraveyard);
            graveyard.nodeName = 'Starship Graveyard';
            return graveyard;
        }
    }

    generateOuterReachesElement(roll) {
        if (roll <= 25) {
            const planet = createNode(NodeTypes.Planet);
            planet.nodeName = this.generatePlanetName();
            return planet;
        } else if (roll <= 45) {
            const gasGiant = createNode(NodeTypes.GasGiant);
            gasGiant.nodeName = this.generateGasGiantName();
            return gasGiant;
        } else if (roll <= 65) {
            const asteroids = createNode(NodeTypes.AsteroidBelt);
            asteroids.nodeName = 'Asteroid Belt';
            return asteroids;
        } else if (roll <= 75) {
            const cluster = createNode(NodeTypes.AsteroidCluster);
            cluster.nodeName = 'Asteroid Cluster';
            return cluster;
        } else if (roll <= 85) {
            const derelict = createNode(NodeTypes.DerelictStation);
            derelict.nodeName = 'Derelict Station';
            return derelict;
        } else if (roll <= 95) {
            const graveyard = createNode(NodeTypes.StarshipGraveyard);
            graveyard.nodeName = 'Starship Graveyard';
            return graveyard;
        } else {
            const cloud = createNode(NodeTypes.DustCloud);
            cloud.nodeName = 'Dust Cloud';
            return cloud;
        }
    }

    generatePlanetName() {
        const prefixes = [
            'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta',
            'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi'
        ];
        
        const suffixes = [
            'Prime', 'Secundus', 'Tertius', 'Quartus', 'Quintus',
            'Majoris', 'Minoris', 'Extremis', 'Ultima', 'Proxima'
        ];
        
        const descriptors = [
            'Aurum', 'Ferrum', 'Argentum', 'Plumbum', 'Stannum',
            'Crystalline', 'Volcanic', 'Glacial', 'Barren', 'Verdant'
        ];
        
        if (Chance(0.4)) {
            return ChooseFrom(prefixes) + ' ' + ChooseFrom(suffixes);
        } else if (Chance(0.3)) {
            return ChooseFrom(descriptors) + ' ' + ChooseFrom(suffixes);
        } else {
            // Generate exotic name
            const consonants = 'bcdfghjklmnpqrstvwxyz';
            const vowels = 'aeiou';
            let name = '';
            const length = Random.nextInt(4, 8);
            
            for (let i = 0; i < length; i++) {
                if (i % 2 === 0) {
                    name += ChooseFrom(consonants.split(''));
                } else {
                    name += ChooseFrom(vowels.split(''));
                }
            }
            
            return name.charAt(0).toUpperCase() + name.slice(1);
        }
    }

    generateGasGiantName() {
        const names = [
            'Jovian', 'Saturnine', 'Neptunian', 'Uranian', 'Titanic',
            'Colossal', 'Massive', 'Stormy', 'Tempest', 'Cyclonic',
            'Atmospheric', 'Clouded', 'Shrouded', 'Wreathed', 'Veiled'
        ];
        
        const suffixes = [
            'Giant', 'Colossus', 'Behemoth', 'Titan', 'Leviathan',
            'Mass', 'Body', 'Sphere', 'Orb', 'Formation'
        ];
        
        return ChooseFrom(names) + ' ' + ChooseFrom(suffixes);
    }

    getZoneSizeString() {
        switch (this.zoneSize) {
            case 'Weak':
                return 'Weak Influence';
            case 'Normal':
                return 'Normal Influence';
            case 'Dominant':
                return 'Dominant Influence';
            default:
                return 'Unknown Influence';
        }
    }

    updateDescription() {
        let desc = `<h3>${this.nodeName}</h3>`;
        desc += `<p><strong>Zone Influence:</strong> ${this.getZoneSizeString()}</p>`;
        
        if (this.children.length === 0) {
            desc += `<p>This system's ${this.nodeName} is empty and barren. Maybe there was something here once, but there's nothing left now.</p>`;
        } else {
            desc += `<p>This orbital zone contains ${this.children.length} significant stellar object(s):</p>`;
            desc += '<ul>';
            for (const child of this.children) {
                desc += `<li><strong>${child.nodeName}</strong> (${child.type.replace('-', ' ')})</li>`;
            }
            desc += '</ul>';
        }
        
        // Add zone-specific information
        switch (this.zone) {
            case 'InnerCauldron':
                desc += '<p><em>The Inner Cauldron is closest to the star, characterized by intense heat and radiation.</em></p>';
                break;
            case 'PrimaryBiosphere':
                desc += '<p><em>The Primary Biosphere is the habitable zone where life is most likely to flourish.</em></p>';
                break;
            case 'OuterReaches':
                desc += '<p><em>The Outer Reaches are the cold, distant regions of the system.</em></p>';
                break;
        }
        
        this.description = desc;
    }

    addPlanet(forceInhabitable = false) {
        const systemNode = this.parent;
        if (systemNode && systemNode instanceof SystemNode) {
            return systemNode.addPlanet(this.zone, forceInhabitable);
        }
        return null;
    }

    getContextMenuItems() {
        const items = [
            { label: 'Add Planet', action: 'add-planet' },
            { label: 'Add Gas Giant', action: 'add-gas-giant' },
            { label: 'Add Asteroid Belt', action: 'add-asteroid-belt' },
            { label: 'Add Asteroid Cluster', action: 'add-asteroid-cluster' },
            { label: 'Add Derelict Station', action: 'add-derelict-station' },
            { label: 'Add Dust Cloud', action: 'add-dust-cloud' },
            { label: 'Add Solar Flares', action: 'add-solar-flares' },
            { label: 'Add Radiation Bursts', action: 'add-radiation-bursts' },
            { label: 'Add Starship Graveyard', action: 'add-starship-graveyard' },
            { type: 'separator' },
            { label: 'Regenerate Zone Content', action: 'generate' },
            { type: 'separator' },
            { label: 'Edit Description', action: 'edit-description' }
        ];
        
        return items;
    }

    toJSON() {
        const json = super.toJSON();
        json.zone = this.zone;
        json.zoneSize = this.zoneSize;
        return json;
    }

    static fromJSON(data) {
        const node = new ZoneNode(data.id);
        
        // Restore base properties
        Object.assign(node, {
            nodeName: data.nodeName || 'Zone',
            description: data.description || '',
            customDescription: data.customDescription || '',
            pageReference: data.pageReference || '',
            isGenerated: data.isGenerated || false,
            fontWeight: data.fontWeight || 'normal',
            fontStyle: data.fontStyle || 'italic',
            fontForeground: data.fontForeground || '#000000'
        });
        
        // Restore zone-specific properties
        Object.assign(node, {
            zone: data.zone || 'PrimaryBiosphere',
            zoneSize: data.zoneSize || 'Normal'
        });
        
        // Restore children
        if (data.children) {
            for (const childData of data.children) {
                const child = createNode(childData.type);
                const restoredChild = child.constructor.fromJSON ? 
                    child.constructor.fromJSON(childData) : 
                    NodeBase.fromJSON(childData);
                node.addChild(restoredChild);
            }
        }
        
        return node;
    }
}

window.ZoneNode = ZoneNode;